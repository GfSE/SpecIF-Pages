"use strict";
/*!    SpecIF: Generate Specif classes from the Ontology.
    Dependencies: -
    (C)copyright enso managers gmbh (http://enso-managers.de)
    License and terms of use: Apache 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
    Author: se@enso-managers.de, Berlin
    We appreciate any correction, comment or contribution as Github issue (https://github.com/enso-managers/SpecIF-Tools/issues)
*/class COntology{constructor(e){this.headings=[],this.organizerClasses=[],this.modelElementClasses=[],this.termCategories=new Map([["resourceClass",{synonymStatement:"SpecIF:isSynonymOfResource",prefix:CONFIG.prefixRC}],["statementClass",{synonymStatement:"SpecIF:isSynonymOfStatement",prefix:CONFIG.prefixSC}],["propertyClass",{synonymStatement:"SpecIF:isSynonymOfProperty",prefix:CONFIG.prefixPC}],["propertyValue",{synonymStatement:"SpecIF:isSynonymOfValue",prefix:CONFIG.prefixV}]]),this.termPrincipalClasses=new Map([["SpecIF:TermResourceClass","R-FolderTermsResourceClass"],["SpecIF:TermStatementClass","R-FolderTermsStatementClass"],["SpecIF:TermPropertyClass","R-FolderTermsPropertyClass"],["SpecIF:TermPropertyValue","R-FolderTermsPropertyValue"]]),this.termClasses=["SpecIF:TermResourceClass","SpecIF:TermStatementClass","SpecIF:TermPropertyClassString","SpecIF:TermPropertyClassBoolean","SpecIF:TermPropertyClassInteger","SpecIF:TermPropertyClassReal","SpecIF:TermPropertyClassTimestamp","SpecIF:TermPropertyClassDuration","SpecIF:TermPropertyClassURI","SpecIF:TermPropertyValue"],this.primitiveDataTypes=new Map([["RC-SpecifTermpropertyclassstring",XsDataType.String],["RC-SpecifTermpropertyclassboolean",XsDataType.Boolean],["RC-SpecifTermpropertyclassinteger",XsDataType.Integer],["RC-SpecifTermpropertyclassreal",XsDataType.Double],["RC-SpecifTermpropertyclasstimestamp",XsDataType.DateTime],["RC-SpecifTermpropertyclassduration",XsDataType.Duration],["RC-SpecifTermpropertyclassuri",XsDataType.AnyURI]]),this.termDefaultValues=["SpecIF:DefaultValueString","SpecIF:DefaultValueBoolean","SpecIF:DefaultValueInteger","SpecIF:DefaultValueReal","SpecIF:DefaultValueTimestamp","SpecIF:DefaultValueDuration","SpecIF:DefaultValueAnyURI"],this.eligibleLifecycles=["SpecIF:LifecycleStatusReleased","SpecIF:LifecycleStatusEquivalent","SpecIF:LifecycleStatusSubmitted"];let t=this.data=e;return this.data.nodes=(e.nodes||e.hierarchies).filter((t=>{let s=LIB.itemByKey(e.resources,t.resource);return this.valueByTitle(s,CONFIG.propClassType)==CONFIG.resClassOntology})),e.nodes.length<1?(message.show("No ontology found.",{severity:"warning"}),void(this.data=void 0)):(this.data.$schema.includes("v1.1")&&(this.data.$schema=this.data.$schema.replace("v1.1","v1.2"),this.data.resources.forEach((e=>{e.properties.forEach((e=>{let s=LIB.itemByKey(t.propertyClasses,e.class),a=LIB.itemByKey(t.dataTypes,s.dataType);e.values=e.values.map((e=>a.enumeration?{id:e}:e))}))}))),this.namespaces=this.getNamespaces(),this.headings=this.getHeadings(),this.organizerClasses=this.getOrganizerClasses(),this.modelElementClasses=this.getModelElementClasses(),this.checkConstraints()?void(this.options={}):(message.show("The Ontology has not been loaded, because one or more constraints are violated. Please see the browser log for details.",{severity:"error"}),void(this.data=void 0)))}isValid(){return this.data&&this.data.id&&this.data.nodes.length>0&&this.checkConstraints()}getTermResources(e,t,s){let a=t.replace(/^dc:/,"dcterms:");return e=e.toLowerCase(),this.data.resources.filter((t=>{let i=this.valueByTitle(t,COntology.propClassTermStatus),r=LIB.valuesByTitle(t,[CONFIG.propClassTerm],this.data);return r.length>1&&console.warn("Ontology: Term "+t.id+" has multiple values ("+r.toString()+")"),r.length>0&&LIB.languageTextOf(r[0],{targetLanguage:"default"})==a&&(!s||!s.eligibleOnly||this.eligibleLifecycles.includes(i))&&("all"==e||LIB.classTitleOf(t.class,this.data.resourceClasses).toLowerCase().includes(e))}))}getTermResource(e,t,s){let a=this.getTermResources(e,t,s);if(a.length>1&&console.warn("Ontology: Multiple resources describe term '"+t+"': "+a.map((e=>e.id)).toString()),a.length>0)return a[0]}getTerms(e,t){t||(t={}),Array.isArray(t.lifeCycles)?LIB.cacheE(t.lifeCycles,"SpecIF:LifecycleStatusReleased"):t.lifeCycles=["SpecIF:LifecycleStatusReleased"];let s=Array.from(this.termCategories.keys());if(s.includes(e))return this.data.resources.filter((s=>LIB.classTitleOf(s.class,this.data.resourceClasses).toLowerCase().includes(e.toLowerCase())&&this.hasSelectedStatus(s,t))).map((t=>this.makeIdAndTitle(t,this.termCategories.get(e).prefix)));throw Error("Programming Error: Unknown category '"+e+"'; must be one of "+s.toString())}getClassId(e,t){if(RE.vocabularyTerm.test(t)){let s=this.getTermResource(e,t);if(s){let t=this.termCategories.get(e);if(t)return this.makeIdAndTitle(s,t.prefix).id;throw Error("Programming Error: Unknown category '"+e+"'")}}}getPreferredTerm(e,t){if(t.startsWith("dcterms:"))return t;let s=this.getTermResource(e,t);if(s){if("SpecIF:LifecycleStatusReleased"==this.valueByTitle(s,COntology.propClassTermStatus))return t;let a=this.termCategories.get(e),i=a?[a]:Array.from(this.termCategories.values()),r=this.statementsByTitle(s,i.map((e=>e.synonymStatement)),{asSubject:!0,asObject:!0}).map((e=>LIB.itemById(this.data.resources,e.object.id==s.id?e.subject.id:e.object.id))).filter((e=>"SpecIF:LifecycleStatusReleased"==this.valueByTitle(e,COntology.propClassTermStatus)));if(r.length<1)return t;r.length>1&&console.warn("Ontology: Multiple equivalent terms are released: ",r.map((e=>e.id)).toString());let l=this.valueByTitle(r[0],CONFIG.propClassTerm);return console.info("Ontology: Preferred term assigned: "+t+" → "+l),l}return t}getLocalTerms(e){let t=LIB.valuesByTitle(e,[CONFIG.propClassLocalTerm],this.data);return Array.isArray(t)&&t.length>0?t[0]:void 0}getDescriptions(e){let t=LIB.valuesByTitle(e,[CONFIG.propClassDesc],this.data);return Array.isArray(t)&&t.length>0?t[0]:void 0}localize(e,t){if(RE.vocabularyTerm.test(e)){let s=this.getTermResource("all",e,{eligibleOnly:!0});if(s){let e=[];if(t.plural){if(e=LIB.valuesByTitle(s,["SpecIF:LocalTermPlural"],this.data),e.length<1){let t=this.statementsByTitle(s,["SpecIF:isPluralOfResource"],{asSubject:!1,asObject:!0});if(t.length>0){let s=LIB.itemByKey(this.data.resources,t[0].subject);e=LIB.valuesByTitle(s,["SpecIF:LocalTerm"],this.data)}}}else e=LIB.valuesByTitle(s,["SpecIF:LocalTerm"],this.data);if(e.length>0){return LIB.languageTextOf(e[0],t)}}}return e}globalize(e,t){if(RE.vocabularyTerm.test(t))return t;let s,a=this.data.resources.filter((a=>{if(s=LIB.itemByKey(this.data.resourceClasses,a.class),this.termClasses.includes(LIB.titleOf(s))&&(LIB.titleOf(s).toLowerCase().includes(e.toLowerCase())||["all","any"].includes(e))){let e=LIB.valuesByTitle(a,["SpecIF:LocalTerm","SpecIF:LocalTermPlural"],this.data);for(let s of e)for(var i of s)if(i.text.toLowerCase()==t.toLowerCase())return!0}return!1}));if(a.length>0)for(let e of this.eligibleLifecycles)for(let s of a)if(this.valueByTitle(s,COntology.propClassTermStatus)==e){let e=this.valueByTitle(s,CONFIG.propClassTerm);return console.info("Ontology: Global term assigned: "+t+" → "+e),e}return t}normalize(e,t){let s=this.globalize(e,t);return s=this.getPreferredTerm(e,s),s}getTermValue(e,t,s){let a=this.getTermResource(e,t);if(a)return this.valueByTitle(a,s)}propertyClassIsText(e){let t=this.getTermValue("propertyClass",e,"SpecIF:StringMaxLength");return null==t||"number"==typeof t&&t>CONFIG.textThreshold}propertyClassIsFormatted(e){return this.getTermValue("propertyClass",e,"SpecIF:TextFormat")==SpecifTextFormat.Xhtml}getIcon(e,t){return this.getTermValue(e,t,"SpecIF:Icon")}changeNamespace(e,t){let s=this;if(!t.targetNamespaces||t.targetNamespaces.length<1)return e;let a=this.getTermResource("all",e,{eligibleOnly:!0});if(a){let i=function(e){let t=LIB.itemByKey(s.data.resourceClasses,e);for(let[e,a]of s.termCategories)if(t.title.toLowerCase().includes(e.toLowerCase()))return a.synonymStatement;throw new Error("No synonym statement found for '"+e.id+"'.")}(a.class),r=function(e,a){let i=[];for(var r of a){if(i=e.filter((e=>s.valueByTitle(e,CONFIG.propClassTerm).startsWith(r)&&(t.lifeCycles??s.eligibleLifecycles).includes(s.valueByTitle(e,COntology.propClassTermStatus)))),i.length>1)for(let e of t.lifeCycles??s.eligibleLifecycles)if(i=i.filter((t=>s.valueByTitle(t,COntology.propClassTermStatus)==e)),!(i.length<1)){i.length>1&&console.warn('Ontology: Multiple terms of a desired namespace with lifecycleStatus "'+e+'" are synonyms: ',i.map((e=>e.id)).toString());break}if(i.length>0)return i[0]}}(this.statementsByTitle(a,[i],{asSubject:!0,asObject:!0}).map((e=>LIB.itemById(this.data.resources,e.object.id==a.id?e.subject.id:e.object.id))),t.targetNamespaces);if(r){let t=this.valueByTitle(r,CONFIG.propClassTerm);return console.info("Ontology: Term with desired namespace assigned: "+e+" → "+t),t}return e}return e}generateSpecifClasses(e){if(Array.isArray(e.domains)&&e.domains.length>0||Array.isArray(e.terms)&&e.terms.length>0){this.options=e,Array.isArray(this.options.lifeCycles)?LIB.cacheE(this.options.lifeCycles,"SpecIF:LifecycleStatusReleased"):this.options.lifeCycles=["SpecIF:LifecycleStatusReleased"];let t="P-SpecifClasses",s=(new Date).toISOString();if(Array.isArray(e.domains)){let s="";e.domains.forEach((e=>{s+=e})),t+="-"+simpleHash(s)}if(Array.isArray(e.terms)){let s="";e.terms.forEach((e=>{s+=e})),t+="-"+simpleHash(s)}for(this.required={sTL:[]},this.generated={dTL:[],pCL:[],rCL:[],sCL:[],rL:[],hL:[]},[{resultL:this.generated.pCL,classes:Array.from(this.primitiveDataTypes.keys()),fn:this.makePC.bind(this)},{resultL:this.generated.rCL,classes:["RC-SpecifTermresourceclass"],fn:this.makeRC.bind(this)},{resultL:this.generated.sCL,classes:["RC-SpecifTermstatementclass"],fn:this.makeSC.bind(this)}].forEach((e=>{LIB.cacheL(e.resultL,this.makeClasses(e.classes,e.fn))}));this.required.sTL.length>0;){let e=[].concat(this.required.sTL);this.required.sTL.length=0,LIB.cacheL(this.generated.sCL,e.map(this.makeSC.bind(this)))}if(this.options.domains&&this.options.domains.includes("SpecIF:DomainOntology")){let e="R-FolderOntology";this.generated.rL.push(LIB.itemByKey(this.data.resources,{id:e}));let t={id:LIB.replacePrefix(CONFIG.prefixN,e),resource:{id:e},nodes:[],changedAt:s};Array.from(this.termPrincipalClasses.values(),(e=>{this.generated.rL.push(LIB.itemByKey(this.data.resources,{id:e})),t.nodes.push({id:LIB.replacePrefix(CONFIG.prefixN,e),resource:{id:e},nodes:[],changedAt:s})})),this.generated.hL.push(t)}return Object.assign(e.delta?{}:app.standards.makeTemplate(),e.delta?{}:{id:t,title:[{text:"SpecIF Classes"+(e.domains?" for "+e.domains.toString().replace(/:/g," "):""),format:SpecifTextFormat.Plain,language:"en"}],description:[{text:"A set of SpecIF Classes derived from a SpecIF Ontology"+(e.domains?" for the domain"+(e.domains.length<2?" ":"s ")+e.domains.toString().replace(/,/g,", ")+".":""),format:SpecifTextFormat.Plain,language:"en"}]},{dataTypes:this.generated.dTL,propertyClasses:this.generated.pCL,resourceClasses:this.generated.rCL,statementClasses:this.generated.sCL,resources:this.generated.rL,nodes:this.generated.hL})}return message.show("No domain or term specified, so no classes will be generated.",{severity:"warning"}),app.standards.makeTemplate()}hasSelectedStatus(e,t){if(!t||!t.lifeCycles||t.lifeCycles.length<1)return!0;let s=LIB.valuesByTitle(e,[COntology.propClassTermStatus],this.data);for(let e of s)if(t.lifeCycles.includes(LIB.displayValueOf(e)))return!0;return!1}makeClasses(e,t){let s=this,a=[],i=LIB.referencedResourcesByClass(this.data.resources,this.data.nodes,e);if(i.length>0){let e=i.filter((function(e){return s.hasSelectedStatus(e,s.options)&&(t(e)||a(e));function t(e){if(Array.isArray(s.options.domains)){let t=LIB.valuesByTitle(e,[CONFIG.propClassDomain],s.data);for(let e of t)if(s.options.domains.includes(LIB.displayValueOf(e)))return!0}return!1}function a(e){if(Array.isArray(s.options.terms)){let t=LIB.valuesByTitle(e,[CONFIG.propClassTerm],s.data);if(t.length>0&&s.options.terms.includes(LIB.displayValueOf(t[0])))return!0}return!1}}));a=LIB.forAll(e,t)}return a}makeDT(e){let t,s=this,a=this.primitiveDataTypes.get(e.class.id),i=this.makeIdAndTitle(e,CONFIG.prefixPC),r=LIB.replacePrefix(CONFIG.prefixDT,i.id),l=LIB.replacePrefix(CONFIG.prefixV,i.id),n=this.statementsByTitle(e,["SpecIF:hasEnumValue"],{asSubject:!0}).map((e=>LIB.itemById(this.data.resources,e.object.id))),o=LIB.forAll(n,((e,t)=>{let s=LIB.valuesByTitle(e,[CONFIG.propClassTerm],this.data);if(s.length>0)return{id:this.valueByTitle(e,CONFIG.propClassId)||l+"-"+t.toString(),value:s[0]};console.warn("Ontology: Property value term '"+e.id+"' is undefined")})),c={};switch(a){case XsDataType.String:let s=this.valueByTitle(e,"SpecIF:StringMaxLength");if("256"===s)t=CONFIG.prefixDT+"ShortString";else t=s?CONFIG.prefixDT+"String"+(s?"-LE"+s:""):CONFIG.prefixDT+"Text";c={id:t,title:s?"String <="+s:"Plain or formatted Text",description:[{text:"Text string"+(o.length>0?" with enumerated values for "+i.title:s?" with maximum length "+s:"")}],maxLength:s?parseInt(s):void 0};break;case XsDataType.Boolean:c={id:CONFIG.prefixDT+"Boolean",title:"Boolean Value",description:[{text:"A Boolean value."}]};break;case XsDataType.Integer:let a=this.valueByTitle(e,"SpecIF:IntegerMaxInclusive"),r=this.valueByTitle(e,"SpecIF:IntegerMinInclusive");t=CONFIG.prefixDT+"Integer",r==CONFIG.minInteger&&a==CONFIG.maxInteger||(t+=(r?"-GE"+r:"")+(a?"-LE"+a:"")),c={id:t,title:"Integer Value"+(r?" >="+r:"")+(a?" <="+a:""),description:[{text:"A numerical integer value"+(r&&a?" with minimum value "+r+" and maximum value "+a:r?" with minimum value "+r:a?" with maximum value "+a:"")+"."}],minInclusive:r?parseInt(r):void 0,maxInclusive:a?parseInt(a):void 0};break;case XsDataType.Double:let l=this.valueByTitle(e,"SpecIF:RealFractionDigits"),n=this.valueByTitle(e,"SpecIF:RealMaxInclusive"),p=this.valueByTitle(e,"SpecIF:RealMinInclusive");c={id:CONFIG.prefixDT+"Real"+(p?"-GE"+p:"")+(n?"-LE"+n:"")+(l?"-FD"+l:""),title:"Real Value"+(p?" >="+p:"")+(n?" <="+n:"")+(l?" "+l+"digits":""),description:[{text:"A numerical floating point number (double precision)"+(p&&n?" with minimum value "+p+" and maximum value "+n:p?" with minimum value "+p:n?" with maximum value "+n:"")+(l?" having no more than "+l+" digits":"")+"."}],minInclusive:p?parseFloat(p):void 0,maxInclusive:n?parseFloat(n):void 0,fractionDigits:l?parseInt(l):void 0};break;case XsDataType.DateTime:c={id:CONFIG.prefixDT+"DateTime",title:"Date/Time",description:[{text:"Date or timestamp in ISO-8601 format."}]};break;case XsDataType.Duration:c={id:CONFIG.prefixDT+"Duration",title:"Duration",description:[{text:"A duration as defined by the ISO 8601 ABNF for 'duration'."}]};break;case XsDataType.AnyURI:c={id:CONFIG.prefixDT+"AnyURI",title:"Universal Resource Identifier (URI)",description:[{text:"A universal resource identifier (URI), according to RFC3986."}]}}return c.type=a,o.length>0&&(c.id=r,c.title=i.title,c.enumeration=o),c.revision=this.valueByTitle(e,"SpecIF:Revision")||e.revision,c.changedAt=e.changedAt,this.options.adoptOntologyDataTypes&&(c=function(e){for(let t of s.data.dataTypes)if(LIB.equalDT(e,t))return t}(c)||c),LIB.cacheE(this.generated.dTL,c),c}makePC(e){let t=this.makeDT(e),s=LIB.valuesByTitle(e,this.termDefaultValues,this.data);return Object.assign(this.makeItem(e,CONFIG.prefixPC),{dataType:this.options.referencesWithoutRevision?LIB.makeKey(t.id):LIB.makeKey(t),format:this.valueByTitle(e,"SpecIF:TextFormat"),required:LIB.isTrue(this.valueByTitle(e,"SpecIF:isRequired"))||void 0,multiple:LIB.isTrue(this.valueByTitle(e,"SpecIF:multiple"))||void 0,values:s.length>0&&(t.type!=XsDataType.Boolean||"true"==s[0])?s:void 0})}makeRC(e){let t,s=LIB.valuesByTitle(e,["SpecIF:Instantiation"],this.data),a=this.extendingClassOf(e,CONFIG.prefixRC),i=this.propertyClassesOf(e);return a&&(t=LIB.makeKey(a.id),Array.isArray(a.propertyClasses)&&a.propertyClasses.length>0&&i.length>0&&(a=LIB.getExtendedClasses(this.generated.rCL,[t])[0],i=i.filter((e=>LIB.referenceIndex(a.propertyClasses,e)<0)))),Object.assign(this.makeItem(e,CONFIG.prefixRC),{extends:t,instantiation:s.map((e=>LIB.displayValueOf(e,{lookupValues:!0}))),isHeading:LIB.isTrue(this.valueByTitle(e,"SpecIF:isHeading"))||void 0,icon:this.valueByTitle(e,"SpecIF:Icon"),propertyClasses:i.length>0?i.map((e=>({id:e.id}))):void 0,changedAt:this.latestOf([e.changedAt].concat(i.map((e=>e.date))))})}makeSC(e){let t,s=LIB.valuesByTitle(e,["SpecIF:Instantiation"],this.data),a=this.extendingClassOf(e,CONFIG.prefixSC),i=this.propertyClassesOf(e),r=this.eligibleClassesOf(e,["SpecIF:isEligibleAsSubject"]),l=this.eligibleClassesOf(e,["SpecIF:isEligibleAsObject"]);return a&&(t=LIB.makeKey(a.id),Array.isArray(a.propertyClasses)&&a.propertyClasses.length>0&&i.length>0&&(a=LIB.getExtendedClasses(this.generated.sCL,[t])[0],i=i.filter((e=>LIB.referenceIndex(a.propertyClasses,e)<0)))),Object.assign(this.makeItem(e,CONFIG.prefixSC),{extends:t,instantiation:s.map((e=>LIB.displayValueOf(e,{lookupValues:!0}))),isUndirected:LIB.isTrue(this.valueByTitle(e,"SpecIF:isUndirected"))||void 0,icon:this.valueByTitle(e,"SpecIF:Icon"),subjectClasses:r,objectClasses:l,propertyClasses:i.length>0?i.map((e=>({id:e.id}))):void 0,changedAt:this.latestOf([e.changedAt].concat(i.map((e=>e.date))))})}extendingClassOf(e,t){if([CONFIG.prefixRC,CONFIG.prefixSC].includes(t)){let s=this.statementsByTitle(e,t==CONFIG.prefixRC?["SpecIF:isSpecializationOfResource"]:["SpecIF:isSpecializationOfStatement"],{asSubject:!0});if(s.length>1&&(console.warn("Ontology: Term "+e.id+" has more than one extended class; the first found prevails."),s.length=1),s.length>0){let e,a=LIB.itemByKey(this.data.resources,s[0].object);switch(t){case CONFIG.prefixRC:e=this.makeRC(a),LIB.cacheE(this.generated.rCL,e);break;case CONFIG.prefixSC:e=this.makeSC(a),LIB.cacheE(this.generated.sCL,e)}return e}}}propertyClassesOf(e){let t=[],s=this.statementsByTitle(e,["SpecIF:hasProperty"],{asSubject:!0});for(let e of s){let s=LIB.itemByKey(this.data.resources,e.object),a=this.makeIdAndTitle(s,CONFIG.prefixPC);LIB.cacheE(t,{id:a.id,date:e.changedAt}),LIB.cacheE(this.generated.pCL,this.makePC(s))}return t}eligibleClassesOf(e,t){let s=[],a=this.statementsByTitle(e,t,{asObject:!0});for(let e of a){let t=LIB.itemByKey(this.data.resources,e.subject),a=this.makeIdAndTitle(t,t.class.id==CONFIG.prefixRC+"SpecifTermresourceclass"?CONFIG.prefixRC:CONFIG.prefixSC);this.hasSelectedStatus(t,this.options)&&(LIB.cacheE(s,{id:a.id}),t.class.id==CONFIG.prefixRC+"SpecifTermresourceclass"?LIB.indexById(this.generated.rCL,a.id)<0&&LIB.cacheE(this.generated.rCL,this.makeRC(t)):LIB.indexById(this.generated.sCL,a.id)<0&&LIB.cacheE(this.required.sTL,t))}if(s.length>0)return s;a.length>0&&console.warn("Ontology: All classes of "+e.id+" with type "+t.join()+" have insufficient lifecycle status")}makeItem(e,t){let s,a=this.makeIdAndTitle(e,t),i=LIB.valuesByTitle(e,[CONFIG.propClassDesc],this.data);return i.length>1&&console.info("Ontology: Only the fist value of the description property will be used for the class generated from "+e.id+" with title "+a.title+"."),i.length>0&&(s=i[0],s.format=LIB.isHTML(s.text)?SpecifTextFormat.Xhtml:SpecifTextFormat.Plain),{id:a.id,revision:this.valueByTitle(e,"SpecIF:Revision")||e.revision,title:a.title,description:s,changedAt:e.changedAt}}makeStatementsIsNamespace(){let e=LIB.itemBy(this.data.statementClasses,"title","SpecIF:isNamespace");if(e){for(var t=this.data.statements.length-1;t>-1;t--)"SpecIF:isNamespace"==LIB.classTitleOf(this.data.statements[t].class,this.data.statementClasses)&&this.data.statements.splice(t,1);let a=(new Date).toISOString();for(var s of this.data.resources)if(this.termClasses.includes(LIB.classTitleOf(s.class,this.data.resourceClasses))){let t=this.valueByTitle(s,CONFIG.propClassTerm),i=RE.splitVocabularyTerm.exec(t);if(Array.isArray(i)&&i[1]){let t=LIB.makeKey(e),r=!0;for(let[e,l]of this.namespaces)if(i[1]==e){this.data.statements.push({id:LIB.genID(CONFIG.prefixS),changedAt:a,class:t,subject:LIB.makeKey(l.id),object:LIB.makeKey(s)}),r=!1;break}r&&console.warn("Ontology: No namespace found for "+s.id)}else console.warn("Ontology: No namespace given for "+s.id)}}else console.warn("Ontology: No statementClass 'SpecIF:isNamespace' defined")}latestOf(e){if(!Array.isArray(e)||e.length<1)return;const t=e.filter((e=>"string"==typeof e&&RE.IsoDateTime.test(e)));return t.length<1?void 0:t.reduce(((e,t)=>t>e?t:e))}checkConstraints(){for(var e of(this.makeStatementsIsNamespace(),this.data.resources))if(this.termClasses.includes(LIB.classTitleOf(e.class,this.data.resourceClasses))){let t=this.valueByTitle(e,CONFIG.propClassTerm);t?RE.splitVocabularyTerm.test(t)||console.error("Ontology: Term "+e.id+" has no namespace, so it is not a valid term name."):console.error("Ontology: No term name defined for "+e.id+".");let s=LIB.valuesByTitle(e,[CONFIG.propClassDomain],this.data),a=this.valueByTitle(e,COntology.propClassTermStatus);s.length<1&&this.eligibleLifecycles.includes(a)&&(console.warn("Ontology: Term "+e.id+" has no domain, so the default domain 'SpecIF:DomainBase' is assigned."),e.properties.push({class:{id:"PC-Domain"},values:[{id:"V-Domain-00"}]}))}return!0}statementsByTitle(e,t,s){return this.data.statements.filter((a=>t.includes(LIB.classTitleOf(a.class,this.data.statementClasses))&&(s.asSubject&&a.subject.id==e.id||s.asObject&&a.object.id==e.id)))}valueByTitle(e,t){return LIB.valueByTitle(e,t,this.data)}distinctiveCoreOf(e){return e.toCamelCase()}makeIdAndTitle(e,t){const s=CONFIG.prefixPC+"SpecifTerm";let a=LIB.valuesByTitle(e,["dcterms:identifier"],this.data),i=LIB.itemBy(e.properties,"class",{id:s});if(i&&i.values.length>0){let e=LIB.languageTextOf(i.values[0],{targetLanguage:"default"});return{id:a&&a.length>0?LIB.languageTextOf(a[0],{targetLanguage:"default"}).toSpecifId():t+this.distinctiveCoreOf(e),title:e}}console.error("Ontology: No item with id '"+s+"' found in the Ontology or it has no value")}getSpecializationsOf(e,t){if(!["resourceClass","statementClass"].includes(e))return[];let s=this.getTermResource(e,t),a=[t];return s&&(a=this.statementsByTitle(s,["resourceClass"==e?"SpecIF:isSpecializationOfResource":"SpecIF:isSpecializationOfStatement"],{asObject:!0}).map((e=>LIB.itemByKey(this.data.resources,e.subject))).filter((e=>{let t=this.valueByTitle(e,COntology.propClassTermStatus);return this.eligibleLifecycles.includes(t)})).map((e=>this.valueByTitle(e,CONFIG.propClassTerm))),a.forEach((t=>{a=a.concat(this.getSpecializationsOf(e,t))}))),a}getOrganizerClasses(){return[CONFIG.resClassOrganizerClass].concat(this.getSpecializationsOf("resourceClass",CONFIG.resClassOrganizerClass))}getModelElementClasses(){return[CONFIG.resClassModelElement].concat(this.getSpecializationsOf("resourceClass",CONFIG.resClassModelElement))}getHeadings(){return this.data.resources.filter((e=>"SpecIF:TermResourceClass"==LIB.classTitleOf(e.class,this.data.resourceClasses)&&LIB.isTrue(this.valueByTitle(e,"SpecIF:isHeading")))).map((e=>this.valueByTitle(e,CONFIG.propClassTerm)))}getNamespaces(){let e=new Map;return this.data.resources.filter((e=>"SpecIF:Namespace"==LIB.classTitleOf(e.class,this.data.resourceClasses))).forEach((t=>{e.set(this.valueByTitle(t,CONFIG.propClassTerm),{id:t.id,url:this.valueByTitle(t,"SpecIF:Home")})})),e}}function getOntology(e){return new Promise(((t,s)=>{LIB.httpGet({url:e+"?"+(new Date).toISOString(),responseType:"arraybuffer",withCredentials:!1,done:e=>{let a=JSON.parse(LIB.ab2str(e.response)),i=new COntology(a);i.isValid()?t(i):s(new resultMsg({status:539,statusText:"Bad file; Ontology is invalid."}))},fail:s})}))}COntology.propClassTermStatus="SpecIF:TermStatus";