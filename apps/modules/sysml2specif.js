"use strict";
/*!	Transform SysML XMI to SpecIF
    - Parse the XMI file
    - Extract both model-elements and semantic relations in SpecIF Format
    - Model elements with same type and title are NOT consolidated by this transformation
    
    (C)copyright enso managers gmbh (http://enso-managers.de)
    Author: se@enso-managers.de
    License and terms of use: Apache 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
    We appreciate any correction, comment or contribution as Github issue (https://github.com/enso-managers/SpecIF-Tools/issues)

    References:
    [1] S.Friedenthal et al: A Practical Guide to SysML, The MK/OMG Press, Third Edition
*/function sysml2specif(e,t){const s={};if([{id:"rcDefault",type:"resourceClass",term:CONFIG.resClassModelElement},{id:"rcFolder",type:"resourceClass",term:CONFIG.resClassFolder},{id:"rcDiagram",type:"resourceClass",term:CONFIG.resClassView},{id:"rcModelElement",type:"resourceClass",term:CONFIG.resClassModelElement},{id:"rcActor",type:"resourceClass",term:CONFIG.resClassActor},{id:"rcState",type:"resourceClass",term:CONFIG.resClassState},{id:"rcEvent",type:"resourceClass",term:CONFIG.resClassEvent},{id:"rcPackage",type:"resourceClass",term:"uml:Package"},{id:"rcStereotype",type:"resourceClass",term:"uml:Stereotype"},{id:"scDefault",type:"statementClass",term:"SpecIF:relates"},{id:"scControlFlow",type:"statementClass",term:"uml:ControlFlow"},{id:"scTriggers",type:"statementClass",term:"uml:Trigger"},{id:"scTransitionSource",type:"statementClass",term:"uml:TransitionSource"},{id:"scTransitionTarget",type:"statementClass",term:"uml:TransitionTarget"},{id:"scContains",type:"statementClass",term:"SpecIF:contains"},{id:"scHasDiagram",type:"statementClass",term:"uml:ownedDiagram"},{id:"scHasBehavior",type:"statementClass",term:"uml:ownedBehavior"},{id:"scHasPart",type:"statementClass",term:"dcterms:hasPart"},{id:"scSpecializes",type:"statementClass",term:"SpecIF:isSpecializationOf"},{id:"scRealizes",type:"statementClass",term:"uml:Realization"},{id:"scServes",type:"statementClass",term:"SpecIF:serves"},{id:"scAssociatedWith",type:"statementClass",term:"SpecIF:isAssociatedWith"},{id:"scHandles",type:"statementClass",term:"SpecIF:handles"},{id:"scProvides",type:"statementClass",term:"SpecIF:provides"},{id:"scConsumes",type:"statementClass",term:"SpecIF:consumes"},{id:"scShows",type:"statementClass",term:"SpecIF:shows"}].forEach((e=>{let t=app.ontology.getClassId(e.type,e.term);if(t)s[e.id]=t;else{switch(e.type){case"resourceClass":s[e.id]=s.rcDefault;break;case"statementClass":s[e.id]=s.scDefault}console.warn("Cameo Import: Term '"+e.term+"' not found in the ontology, using default term instead.")}})),s.scAggregates=s.scComprises=s.scHasPart,s.scDefault=s.scAssociatedWith,"object"!=typeof t||!t.fileName)throw Error("Programming Error: Cameo import gets no 'options'");let a=Object.assign({mimeType:"application/vnd.xmi+xml",fileDate:(new Date).toISOString(),addElementsToHierarchy:!0,replaceSeparatorNamespace:"*"},t);var i=(new DOMParser).parseFromString(e,"text/xml");return function(e){return e.getElementsByTagName("xmi:exporter")[0].innerHTML.includes("MagicDraw")}(i)?new resultMsg(0,"Cameo Import done","json",function(e,t){function a(t){let s=e.getElementsByTagName("xmi:XMI")[0],a=new Map;return Array.from(s.children,(e=>{let s=e.getAttribute(t);if(s){let i=e.getAttribute("Text");"base_Property"==t?a.set(s,{tag:e.tagName,dir:e.getAttribute("direction")}):i?a.set(s,{tag:e.tagName,text:i}):a.set(s,{tag:e.tagName})}})),a}const i=a("base_Class"),n=a("base_NamedElement"),o=a("base_Abstraction"),l=a("base_Property"),m=new Map,d=Array.from(e.getElementsByTagName("uml:Model")),u=Array.from(e.getElementsByTagName("packagedElement")).filter((e=>"uml:Model"==e.getAttribute("xmi:type"))),p=Array.from(e.getElementsByTagName("uml:Package")),g=Array.from(e.getElementsByTagName("uml:Profile")),y=d.concat(p).concat(u).concat(g);let I,h=app.ontology.generateSpecifClasses({domains:["SpecIF:DomainBase","SpecIF:DomainSystemsEngineering","SpecIF:DomainSystemModelIntegration"],lifeCycles:["SpecIF:LifecycleStatusReleased","SpecIF:LifecycleStatusEquivalent"],referencesWithoutRevision:!0}),f=[],B=[],b=[],k=[],C=[],L=[],A=[],K=[];console.debug("Cameo Import - Models, Packages and Profiles:",d,p,u,g,y);for(let e of y){"uml:Model"==e.tagName&&(h.id=CONFIG.prefixP+e.getAttribute("xmi:id"),h.title=[{text:e.getAttribute("name")}]);let a=e.getAttribute("xmi:id"),i={id:a,class:LIB.makeKey(s.rcFolder),properties:[{class:LIB.makeKey("PC-Name"),values:[[{text:r(e.getAttribute("name"))}]]},{class:LIB.makeKey("PC-Description"),values:[[{text:N(e,{parent:a})}]]},{class:LIB.makeKey("PC-Type"),values:[[{text:e.getAttribute("xmi:type")}]]}],changedAt:t.fileDate},c=S(i,h.id);h.resources.push(i),h.nodes.push(c),x(e,{packageId:"",nodes:c.nodes})}k=k.filter(E),h.resources.forEach((e=>{if(e.class.id==s.rcDefault){let t;t=function t(s){let a=k.filter((e=>e.subject.id==s.id));a.length>1&&console.warn("Cameo Import: Model-elment with id "+e.id+" specializes "+a.length+" classes");for(var i of a){let e=LIB.itemByKey(h.resources,i.object),s=LIB.titleFromProperties(e.properties,h.propertyClasses,{targetLanguage:"default"}),a=LIB.itemByTitle(h.resourceClasses,s);if(a)return a;if(a=t(e),a)return a}}(e),t&&t.id!=s.rcDefault&&(e.class=LIB.makeKey(t.id),console.info("Cameo Import: Re-assigning class "+t.id+" to model-element "+e.id+" with title "+LIB.valueByTitle(e,CONFIG.propClassTitle,h)));let a=i.get(e.id)||n.get(e.id);if(a){if("sysml:InterfaceBlock"==a.tag)return e.class=LIB.makeKey(s.rcState),void console.info("Cameo Import: Reassigning class '"+s.rcState+"' to  model-element "+e.id+" with title "+LIB.valueByTitle(e,CONFIG.propClassTitle,h));if(t=LIB.itemByTitle(h.resourceClasses,a.tag),t){if(e.class=LIB.makeKey(t.id),console.info("Cameo Import: Reassigning class '"+t.id+"' to  model-element "+e.id+" with title "+LIB.valueByTitle(e,CONFIG.propClassTitle,h)),"sysml:Requirement"==a.tag){let t=LIB.propByTitle(e,CONFIG.propClassDesc,h);t&&(t.values=[[{text:a.text}]])}return}let i=LIB.propByTitle(e,CONFIG.propClassType,h);i&&(i.values=[[{text:a.tag}]],console.info("Cameo Import: Assigning stereotype '"+a.tag+"' to  model-element "+e.id+" with title "+LIB.valueByTitle(e,CONFIG.propClassTitle,h)))}}return})),b=b.filter(E).map((e=>{let t=o.get(e.id);if(t){let s=LIB.itemByTitle(h.statementClasses,t.tag);if(s)e.class=LIB.makeKey(s.id),console.info("Cameo Import: Re-assigning class "+s.id+" with title "+t.tag+" to statement "+e.id);else{let s={class:LIB.makeKey("PC-Type"),values:[[{text:t.tag}]]};LIB.addProperty(e,s),console.info("Cameo Import: Assigning stereotype "+t.tag+" to statement "+e.id)}}return e})),L.forEach((e=>{let a,i=e.interfaceBlock;switch(m.get(i)){case"in":e.resource.properties.push({class:"PC-UmlFlowdirection",values:[[{text:e.isConjugated?"out":"in"}]]}),a=e.isConjugated?s.scProvides:s.scConsumes,h.statements.push({id:CONFIG.prefixS+(e.isConjugated?"provides-":"consumes-")+simpleHash(e.resource.id+a+i),class:LIB.makeKey(a),subject:LIB.makeKey(e.resource.id),object:LIB.makeKey(i),changedAt:t.fileDate});break;case"out":e.resource.properties.push({class:"PC-UmlFlowdirection",values:[[{text:e.isConjugated?"in":"out"}]]}),a=e.isConjugated?s.scConsumes:s.scProvides,h.statements.push({id:CONFIG.prefixS+(e.isConjugated?"consumes-":"provides-")+simpleHash(e.resource.id+a+i),class:LIB.makeKey(a),subject:LIB.makeKey(e.resource.id),object:LIB.makeKey(i),changedAt:t.fileDate});break;case"inout":e.resource.properties.push({class:"PC-UmlFlowdirection",values:[[{text:"inout"}]]}),h.statements.push({id:CONFIG.prefixS+"handles-"+simpleHash(e.resource.id+s.scHandles+i),class:LIB.makeKey(s.scHandles),subject:LIB.makeKey(e.resource.id),object:LIB.makeKey(i),changedAt:t.fileDate})}})),A.forEach((e=>{let a=LIB.itemById(L,e.ends[0]),i=LIB.itemById(L,e.ends[1]),r="true"==LIB.valueByTitle(a.resource,"uml:is_Service",h),c="true"==LIB.valueByTitle(i.resource,"uml:is_Service",h);!r||c?r||!c?h.statements.forEach((n=>{if(n.class.id==s.scComprises){if(n.subject.id==a.parent.id&&n.object.id==i.parent.id)return void h.statements.push({id:e.id,class:LIB.makeKey(s.scServes),subject:LIB.makeKey(r&&c?i.id:a.id),object:LIB.makeKey(r&&c?a.id:i.id),changedAt:t.fileDate});n.subject.id==i.parent.id&&n.object.id==a.parent.id&&h.statements.push({id:e.id,class:LIB.makeKey(s.scServes),subject:LIB.makeKey(r&&c?a.id:i.id),object:LIB.makeKey(r&&c?i.id:a.id),changedAt:t.fileDate})}})):h.statements.push({id:e.id,class:LIB.makeKey(s.scServes),subject:LIB.makeKey(i.id),object:LIB.makeKey(a.id),changedAt:t.fileDate}):h.statements.push({id:e.id,class:LIB.makeKey(s.scServes),subject:LIB.makeKey(a.id),object:LIB.makeKey(i.id),changedAt:t.fileDate})})),K.forEach((e=>{let t=LIB.itemById(h.resources,e.id),s=LIB.valueByTitle(t,"dcterms:title",h),a=LIB.valueByTitle(t,"dcterms:type",h),i=LIB.itemById(h.resources,e.source),r=LIB.valueByTitle(i,"dcterms:title",h),c=LIB.valueByTitle(i,"dcterms:type",h),n=LIB.itemById(h.resources,e.target),o=LIB.valueByTitle(n,"dcterms:title",h);"uml:Pseudostate"==c&&r.includes("unnamed")&&(r="entry",LIB.updatePropertyByTitle(i,"dcterms:title",(()=>[[{text:r}]]),h)),"uml:Transition"==a&&s.includes("unnamed")&&LIB.updatePropertyByTitle(t,"dcterms:title",(()=>[[{text:r+"â†’"+o}]]),h)})),h.statements=h.statements.concat(b).concat(k).concat(B);do{I=h.statements.length,h.statements=h.statements.filter(E)}while(I>h.statements.length);return h=LIB.keepUsedClasses(h),console.debug("from SysML:",h,t),h;function x(e,a){function n(e){let t=[];return Array.from(e.children,(e=>{"ownedLiteral"==e.tagName&&t.push({id:e.getAttribute("xmi:id"),txt:e.getAttribute("name")})})),t}function o(e){let t=e.getAttribute("general");if(!t){let s=e.getElementsByTagName("referenceExtension")[0];if(s&&(t=s.getAttribute("referentPath"),t&&t.indexOf("::")>0)){let e=t.toLowerCase().includes("sysml")?"sysml:":"uml:";t=e+t.split("::").pop(),console.debug("Cameo Import: Generalization found in referenceExtension: "+t)}}return t}function d(e,a){let n=T(e,{class:s.rcDefault});h.resources.push(n);let u=S(n,a.packageId),p={packageId:a.packageId,parent:n,nodes:u.nodes};t.addElementsToHierarchy&&a.nodes.push(u),a.packageId&&h.statements.push({id:CONFIG.prefixS+"contains-"+simpleHash(a.packageId+s.scContains+n.id),class:LIB.makeKey(s.scContains),subject:LIB.makeKey(a.packageId),object:LIB.makeKey(n.id),changedAt:t.fileDate}),Array.from(e.children,(e=>{switch(e.tagName){case"ownedComment":break;case"nestedClassifier":d(e,p);break;case"xmi:Extension":j(e,p);break;case"ownedBehavior":switch(e.getAttribute("xmi:type")){case"uml:StateMachine":!function(e,a){let i=T(e,{class:s.rcActor});h.resources.push(i),h.statements.push({id:CONFIG.prefixS+"ownedBehavior-"+simpleHash(a.parent.id+s.scHasBehavior+i.id),class:LIB.makeKey(s.scHasBehavior),subject:LIB.makeKey(a.parent.id),object:LIB.makeKey(i.id),changedAt:t.fileDate}),a.packageId&&h.statements.push({id:CONFIG.prefixS+"contains-"+simpleHash(a.packageId+s.scContains+i.id),class:LIB.makeKey(s.scContains),subject:LIB.makeKey(a.packageId),object:LIB.makeKey(i.id),changedAt:t.fileDate});return void Array.from(e.children,(e=>{switch(e.tagName){case"ownedComment":break;case"xmi:Extension":j(e,Object.assign({},a,{parent:i}));break;case"region":let t=f[f.length-1];D(t.id,e.getAttribute("xmi:id")),r(e,Object.assign({},a,{parent:i,diagram:t}));break;default:c(e)}}));function r(e,a){let i=T(e,{class:s.rcActor});h.resources.push(i),h.statements.push({id:CONFIG.prefixS+"contains-"+simpleHash(a.parent.id+s.scContains+i.id),class:LIB.makeKey(s.scContains),subject:LIB.makeKey(a.parent.id),object:LIB.makeKey(i.id),changedAt:t.fileDate}),Array.from(e.children,(e=>{let n;switch(e.tagName){case"ownedComment":break;case"subvertex":n=T(e,{class:s.rcState}),h.statements.push({id:CONFIG.prefixS+"contains-"+simpleHash(i.id+s.scContains+n.id),class:LIB.makeKey(s.scContains),subject:LIB.makeKey(i.id),object:LIB.makeKey(n.id),changedAt:t.fileDate}),Array.from(e.children,(e=>{if("region"===e.tagName)r(e,Object.assign({},a,{parent:n}))}));break;case"transition":n=T(e,{class:s.rcActor});let o=e.getAttribute("source"),l=e.getAttribute("target"),m={id:n.id,source:o,target:l};h.statements.push({id:CONFIG.prefixS+"startsFrom-"+simpleHash(o+s.scTransitionSource+n.id),class:LIB.makeKey(s.scTransitionSource),subject:LIB.makeKey(n.id),object:LIB.makeKey(o),changedAt:t.fileDate}),h.statements.push({id:CONFIG.prefixS+"endsAt-"+simpleHash(l+s.scTransitionTarget+n.id),class:LIB.makeKey(s.scTransitionTarget),subject:LIB.makeKey(n.id),object:LIB.makeKey(l),changedAt:t.fileDate}),Array.from(e.children,(e=>{switch(e.tagName){case"ownedComment":break;case"trigger":let i=e.getAttribute("event");m.event=i,h.statements.push({id:CONFIG.prefixS+"triggers-"+simpleHash(i+s.scTriggers+n.id),class:LIB.makeKey(s.scTriggers),subject:LIB.makeKey(i),object:LIB.makeKey(n.id),changedAt:t.fileDate}),D(a.diagram.id,i);break;case"effect":v(e,Object.assign({},a,{parent:n}));break;default:c(e)}})),K.push(m);break;default:c(e)}n&&h.resources.push(n)}))}}(e,p);break;case"uml:Activity":v(e,p)}break;case"generalization":!function(e,a){let i=e.getAttribute("xmi:id"),r=o(e);r?k.push({id:i,class:LIB.makeKey(s.scSpecializes),subject:LIB.makeKey(a.parent.id),object:LIB.makeKey(r),changedAt:t.fileDate}):console.warn("Cameo Import: Skipped generalization with id '"+i+"', because it has no attribute 'general'.")}(e,p);break;case"ownedAttribute":!function(e,a){let c,n,o,d,p,g,y;switch(e.getAttribute("xmi:type")){case"uml:Property":if(c=e.getAttribute("xmi:id"),n=e.getAttribute("association"),o=e.getAttribute("type"),d=e.getAttribute("aggregation"),n&&o)y="composite"==d?s.scComprises:"shared"==d?s.scAggregates:void 0,g=e.getAttribute("name"),g&&(h.resources.push({id:c,class:LIB.makeKey(s.rcDefault),properties:[{class:LIB.makeKey("PC-Name"),values:[[{text:r(g)}]]},{class:LIB.makeKey("PC-Type"),values:[[{text:"uml:Class"}]]}],changedAt:t.fileDate}),t.addElementsToHierarchy&&a.nodes.push(S(LIB.makeKey(c),a.parent.id)),k.push({id:CONFIG.prefixS+"specializes-"+simpleHash(c+s.scSpecializes+o),class:LIB.makeKey(s.scSpecializes),subject:LIB.makeKey(c),object:LIB.makeKey(o),changedAt:t.fileDate}),o=c),C.push({associationId:e.getAttribute("association"),associationType:y,thisEnd:LIB.makeKey(a.parent.id),otherEnd:LIB.makeKey(o)}),B.filter((e=>e.object.id==c)).forEach((e=>{D(e.subject.id,o)}));else if("sysml:InterfaceBlock"==i.get(a.parent.id)){o&&h.statements.push({id:c,class:LIB.makeKey(s.scDefault),subject:LIB.makeKey(a.parent.id),object:LIB.makeKey(o),properties:[{class:LIB.makeKey("PC-Type"),values:[[{text:"has data type"}]]}],changedAt:t.fileDate});let e=l.get(c);e&&e.dir&&m.set(a.parent.id,e.dir)}else{let i=T(e,{class:s.rcState});h.resources.push(i),t.addElementsToHierarchy&&u.nodes.push(S(i,a.parent.id)),h.statements.push({id:CONFIG.prefixS+"comprises-"+simpleHash(a.parent.id+s.scComprises+i.id),class:LIB.makeKey(s.scComprises),subject:LIB.makeKey(a.parent.id),object:LIB.makeKey(i.id),changedAt:t.fileDate})}break;case"uml:Port":c=e.getAttribute("xmi:id"),o=e.getAttribute("type"),g=r(e.getAttribute("name")),p=LIB.titleFromProperties(a.parent.properties,h.propertyClasses,{targetLanguage:"default"});let I={id:c,class:LIB.makeKey("RC-UmlPort"),properties:[{class:LIB.makeKey("PC-Name"),values:[[{text:p?p+" Port "+g:g}]]},{class:LIB.makeKey("PC-Type"),values:[[{text:"uml:Port"}]]},{class:LIB.makeKey("PC-UmlIsservice"),values:[e.getAttribute("isService")??"true"]}],changedAt:t.fileDate};h.resources.push(I),h.statements.push({id:CONFIG.prefixS+"hasPart-"+simpleHash(a.parent.id+s.scHasPart+c),class:LIB.makeKey(s.scHasPart),subject:LIB.makeKey(a.parent.id),object:LIB.makeKey(c),changedAt:t.fileDate}),L.push({id:I.id,resource:I,interfaceBlock:o,isConjugated:"true"==e.getAttribute("isConjugated"),parent:a.parent})}}(e,p);break;case"ownedOperation":let a=T(e,{class:s.rcActor});h.resources.push(a),t.addElementsToHierarchy&&u.nodes.push(S(a,n.id)),h.statements.push({id:CONFIG.prefixS+"comprises-"+simpleHash(n.id+s.scComprises+a.id),class:LIB.makeKey(s.scComprises),subject:LIB.makeKey(n.id),object:LIB.makeKey(a.id),changedAt:t.fileDate});break;case"ownedConnector":let g=e.getAttribute("xmi:id"),y=Array.from(e.getElementsByTagName("end"),(e=>e.getAttribute("role")));if(y.length<2)return void console.error("uml:Connector "+g+" has too few ends");if(y.length>2)return void console.error("uml:Connector "+g+" has too many ends");A.push({id:g,ends:[y[0],y[1]]});break;default:c(e)}}))}Array.from(e.children,(e=>{switch(e.tagName){case"ownedComment":break;case"packagedElement":switch(e.getAttribute("xmi:type")){case"uml:DataType":i=T(e,{class:s.rcDefault}),h.resources.push(i),t.addElementsToHierarchy&&a.nodes.push(S(i,a.packageId));break;case"uml:Stereotype":let r=function(e,s){let a=e.getAttribute("xmi:id"),i=N(e,{parent:a}),r={id:CONFIG.prefixRC+a,title:e.getAttribute("name"),description:i?[{text:i}]:void 0,keepEvenIfUnused:!0,changedAt:t.fileDate};return r}(e),c=o(e),l=LIB.itemByTitle(h.resourceClasses,c);r.extends=l?LIB.makeKey(l.id):LIB.makeKey(s.rcDefault),h.resourceClasses.push(r);break;case"uml:Enumeration":let m=e.getAttribute("xmi:id"),d=e.getAttribute("name"),u={id:CONFIG.prefixDT+m,title:d,type:XsDataType.String,enumeration:n(e).map((e=>({id:CONFIG.prefixV+e.id,value:[{text:e.txt}]}))),changedAt:t.fileDate},p=N(e,{parent:m}),g={id:CONFIG.prefixPC+m,title:d,description:p?[{text:p}]:void 0,dataType:LIB.makeKey(u.id),keepEvenIfUnused:!0,changedAt:t.fileDate};h.dataTypes.push(u),h.propertyClasses.push(g)}}var i})),Array.from(e.children,(e=>{let i,r;switch(e.tagName){case"ownedComment":break;case"xmi:Extension":j(e,a);break;case"packagedElement":switch(e.getAttribute("xmi:type")){case"uml:DataType":case"uml:Stereotype":case"uml:Enumeration":case"uml:Association":case"uml:Abstraction":case"uml:Realization":case"uml:Profile":case"uml:Usage":break;case"uml:Package":i=T(e,{class:s.rcPackage}),h.resources.push(i),r=S(i,a.packageId),t.addElementsToHierarchy&&a.nodes.push(r),x(e,{packageId:i.id,nodes:r.nodes});break;case"uml:UseCase":case"uml:Actor":case"uml:Class":d(e,a);break;case"uml:Activity":v(e,a);break;case"uml:CallEvent":case"uml:ChangeEvent":case"uml:SignalEvent":case"uml:TimeEvent":!function(e,a){let i=T(e,{class:s.rcEvent});h.resources.push(i),t.addElementsToHierarchy&&a.nodes.push(S(i,a.packageId));a.packageId&&h.statements.push({id:CONFIG.prefixS+"contains-"+simpleHash(a.packageId+s.scContains+i.id),class:LIB.makeKey(s.scContains),subject:LIB.makeKey(a.packageId),object:LIB.makeKey(i.id),changedAt:t.fileDate})}(e,a)}}})),Array.from(e.children,(e=>{switch(e.tagName){case"ownedComment":case"xmi:Extension":case"profileApplication":break;case"packagedElement":let a=e.getAttribute("xmi:type");switch(a){case"uml:DataType":case"uml:Stereotype":case"uml:Enumeration":case"uml:Package":case"uml:UseCase":case"uml:Actor":case"uml:Class":case"uml:CallEvent":case"uml:ChangeEvent":case"uml:SignalEvent":case"uml:TimeEvent":case"uml:Profile":case"uml:Usage":break;case"uml:Association":!function(e){let a,i,c=e.getAttribute("name"),n=e.getAttribute("xmi:id"),o=C.filter((e=>e.associationId==n));c&&(a=LIB.itemByTitle(h.statementClasses,c),a||(i=[{class:LIB.makeKey("PC-Type"),values:[[{text:r(c)}]]}]));if(1==o.length)h.statements.push({id:n,class:LIB.makeKey(o[0].associationType||(a?a.id:void 0)||s.scAssociatedWith),properties:i||void 0,subject:LIB.makeKey(o[0].thisEnd),object:LIB.makeKey(o[0].otherEnd),changedAt:t.fileDate});else if(2==o.length){let e,r,c;o[0].associationType||o[1].associationType?(o[1].associationType?(e=o[1].associationType,r=o[1].thisEnd,c=o[1].otherEnd):(e=o[0].associationType||(a?a.id:void 0)||s.scAssociatedWith,r=o[0].thisEnd,c=o[0].otherEnd),h.statements.push({id:n,class:LIB.makeKey(e),properties:i||void 0,subject:LIB.makeKey(r),object:LIB.makeKey(c),changedAt:t.fileDate})):console.warn("Cameo Import: Skipping the uml:Association with id "+n+", because it has no direction in RDF terms.")}else if(o.length<1){let a={id:n,properties:i||void 0,changedAt:t.fileDate};Array.from(e.getElementsByTagName("ownedEnd"),(e=>{let t=e.getAttribute("aggregation");t&&["composite","shared"].includes(t)?(a.class=LIB.makeKey("composite"==t?s.scComprises:s.scAggregates),a.object=LIB.makeKey(e.getAttribute("type"))):a.subject=LIB.makeKey(e.getAttribute("type"))})),LIB.isKey(a.class)&&LIB.isKey(a.subject)&&LIB.isKey(a.object)?h.statements.push(a):console.warn("Cameo Import: Skipping the uml:Association with id "+n+", because it has no direction in RDF terms.")}else o.length>2&&(console.error("Cameo Import: Too many association ends found; must be 0, 1 or 2 and is "+o.length),console.info("Cameo Import: Skipping the uml:Association with id "+n+", because it is not referenced by a uml:Class."))}(e);break;case"uml:Abstraction":let i=e.getElementsByTagName("client")[0].getAttribute("xmi:idref"),c=e.getElementsByTagName("supplier")[0].getAttribute("xmi:idref");b.push({id:e.getAttribute("xmi:id"),class:LIB.makeKey(s.scDefault),subject:LIB.makeKey(i),object:LIB.makeKey(c),changedAt:t.fileDate});break;case"uml:Realization":let n=e.getElementsByTagName("client")[0].getAttribute("xmi:idref"),o=e.getElementsByTagName("supplier")[0].getAttribute("xmi:idref"),l={id:e.getAttribute("xmi:id"),class:LIB.makeKey(s.scRealizes||s.scAssociatedWith),subject:LIB.makeKey(n),object:LIB.makeKey(o),changedAt:t.fileDate};h.statements.push(l);break;default:console.info("Cameo Import: Skipping the packagedElement",e,"with name",e.getAttribute("name"),"and type",a,".")}break;default:c(e)}}))}function j(e,a){Array.from(e.getElementsByTagName("ownedDiagram"),(e=>{let i=e.getElementsByTagName("diagram:DiagramRepresentationObject")[0],c=i.getAttribute("type"),n=r(e.getAttribute("name")),o={id:e.getAttribute("xmi:id"),class:LIB.makeKey(s.rcDiagram),properties:[{class:LIB.makeKey("PC-Name"),values:[[{text:n}]]},{class:LIB.makeKey("PC-Type"),values:[[{text:e.getAttribute("xmi:type")}]]},{class:LIB.makeKey("PC-Notation"),values:[[{text:(c.startsWith("SysML")?"":"UML ")+c}]]}],changedAt:t.fileDate};w(o,e),f.push({id:o.id,name:n,type:c}),a.packageId&&h.statements.push({id:CONFIG.prefixS+"contains-"+simpleHash(a.packageId+s.scContains+o.id),class:LIB.makeKey(s.scContains),subject:LIB.makeKey(a.packageId),object:LIB.makeKey(o.id),changedAt:t.fileDate}),Array.from(i.getElementsByTagName("usedElements"),(e=>D(o.id,e.innerHTML))),a.parent&&(D(o.id,a.parent),h.statements.push({id:CONFIG.prefixS+"ownedDiagram-"+simpleHash(a.parent.id+s.scHasDiagram+o.id),class:LIB.makeKey(s.scHasDiagram),subject:LIB.makeKey(a.parent.id),object:LIB.makeKey(o.id),changedAt:t.fileDate})),h.resources.push(o),a.nodes.push({id:CONFIG.prefixN+simpleHash(a.packageId+o.id),resource:LIB.makeKey(o.id),changedAt:t.fileDate})}))}function v(e,a){let i=T(e,{class:s.rcActor});h.resources.push(i),a.packageId&&h.statements.push({id:CONFIG.prefixS+"contains-"+simpleHash(a.packageId+s.scContains+i.id),class:LIB.makeKey(s.scContains),subject:LIB.makeKey(a.packageId),object:LIB.makeKey(i.id),changedAt:t.fileDate}),a.parent&&h.statements.push({id:CONFIG.prefixS+"ownedBehavior-"+simpleHash(a.parent.id+s.scHasBehavior+i.id),class:LIB.makeKey(s.scHasBehavior),subject:LIB.makeKey(a.parent.id),object:LIB.makeKey(i.id),changedAt:t.fileDate}),Array.from(e.children,(e=>{switch(e.tagName){case"xmi:Extension":j(e,Object.assign({},a,{parent:i}));break;case"node":let r=T(e,{class:s.rcActor});h.resources.push(r),h.statements.push({id:CONFIG.prefixS+"contains-"+simpleHash(i.id+s.scContains+r.id),class:LIB.makeKey(s.scContains),subject:LIB.makeKey(i.id),object:LIB.makeKey(r.id),changedAt:t.fileDate})}})),Array.from(e.children,(e=>{switch(e.tagName){case"ownedComment":case"xmi:Extension":case"node":break;case"edge":h.statements.push({id:e.getAttribute("xmi:id"),class:LIB.makeKey(s.scControlFlow),subject:LIB.makeKey(e.getAttribute("source")),object:LIB.makeKey(e.getAttribute("target")),changedAt:t.fileDate});break;default:c(e)}}))}function T(e,s){let a={id:e.getAttribute("xmi:id"),class:s&&s.class?LIB.makeKey(s.class):void 0,properties:[{class:LIB.makeKey("PC-Name"),values:[[{text:s&&s.name?s.name:r(e.getAttribute("name"))||"unnamed "+e.getAttribute("xmi:type")}]]},{class:LIB.makeKey("PC-Type"),values:[[{text:e.getAttribute("xmi:type")}]]}],changedAt:t.fileDate};return w(a,e),a}function S(e,s){return{id:CONFIG.prefixN+simpleHash(s+e.id),resource:LIB.makeKey(e.id),nodes:[],changedAt:t.fileDate}}function N(e,t){let s=[];if(Array.from(e.children,(e=>{if("ownedComment"===e.tagName){let t=e.getAttribute("body");t&&s.push(t)}})),s.length>1&&console.warn("Element "+t.parent+" has more than one comment/description."),s.length>0)return s[0]}function w(e,t){let s=N(t,{parent:e.id});s&&e.properties.push({class:LIB.makeKey("PC-Description"),values:[[{text:s}]]})}function D(e,a){if(e&&a){let i=CONFIG.prefixS+"shows-"+simpleHash(e+s.scShows+a);LIB.indexById(B,i)<0&&B.push({id:i,class:LIB.makeKey(s.scShows),subject:LIB.makeKey(e),object:LIB.makeKey(a),changedAt:t.fileDate})}else console.error("When creating 'shows' statement, the subject or object is undefined",e,a)}function E(e,t,s){if(LIB.isKey(e.subject)&&LIB.isKey(e.object)&&LIB.isKey(e.class)){let t=LIB.itemByKey(h.statementClasses,e.class),a=h.resources.concat(s),i=LIB.itemByKey(a,e.subject),r=LIB.itemByKey(a,e.object),c=i&&r;return t?(c?(c=(!t.subjectClasses||LIB.referenceIndex(t.subjectClasses,i.class)>-1)&&(!t.objectClasses||LIB.referenceIndex(t.objectClasses,r.class)>-1),c||console.info("Cameo Import: Skipping",t.title,"statement "+e.id+" with subject",i," and object",r,", because they violate the statementClass.")):console.info("Cameo Import: Skipping",t.title,"statement "+e.id+", because "+(i?"object "+e.object.id:"subject "+e.subject.id)+" isn't listed as resource resp. statement."),c):(console.warn("Cameo Import: Class "+e.class.id+" for statement "+e.id+" not found."),!1)}return console.warn("Cameo Import: Skipping statement, because class, subject or object is undefined: "+e),!1}}(i,a)):new resultMsg(899,"Cameo Import: Input file is not supported.");function r(e){if(e&&a.replaceSeparatorNamespace){let t=new RegExp("^(.{1,9})\\"+a.replaceSeparatorNamespace+"(.+)$");return e.replace(t,((e,t,s)=>t+":"+s))}return e}function c(e){let t=e.getAttribute("name"),s=" with "+(t?"name '"+t+"' and ":"")+"id '"+e.getAttribute("xmi:id")+"'.";console.info("Cameo Import: Skipping tag '"+e.tagName+"'"+s)}}